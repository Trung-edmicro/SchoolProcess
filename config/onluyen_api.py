"""
OnLuyen API Configuration
C·∫•u h√¨nh API endpoints cho h·ªá th·ªëng OnLuyen
Author: Assistant
Date: 2025-07-26
"""

from typing import Dict, Any, Optional
import requests
from dataclasses import dataclass
from urllib.parse import urljoin
import json
import os


@dataclass
class APIEndpoint:
    """ƒê·ªãnh nghƒ©a m·ªôt API endpoint"""
    name: str
    method: str
    url: str
    default_params: Dict[str, Any] = None
    description: str = ""
    
    def __post_init__(self):
        if self.default_params is None:
            self.default_params = {}


class OnLuyenAPIConfig:
    """C·∫•u h√¨nh API cho h·ªá th·ªëng OnLuyen"""
    
    @classmethod
    def get_auth_base_url(cls) -> str:
        """L·∫•y Auth Base URL t·ª´ environment"""
        return os.getenv('ONLUYEN_AUTH_BASE_URL')
    
    @classmethod  
    def get_school_api_base_url(cls) -> str:
        """L·∫•y School API Base URL t·ª´ environment"""
        return os.getenv('ONLUYEN_SCHOOL_API_BASE_URL')
    
    @classmethod
    def _build_endpoints(cls) -> Dict[str, 'APIEndpoint']:
        """Build endpoints v·ªõi URLs t·ª´ environment"""
        auth_base = cls.get_auth_base_url()
        school_api_base = cls.get_school_api_base_url()
        
        return {
            "login": APIEndpoint(
                name="login",
                method="POST", 
                url=f"{auth_base}/api/account/login",
                description="ƒêƒÉng nh·∫≠p t√†i kho·∫£n"
            ),
            
            "list_teacher": APIEndpoint(
                name="list_teacher",
                method="GET",
                url=f"{school_api_base}/school/list-teacher/%20/1",
                default_params={"pageSize": 10},
                description="L·∫•y danh s√°ch gi√°o vi√™n"
            ),
            
            "list_student": APIEndpoint(
                name="list_student", 
                method="GET",
                url=f"{school_api_base}/school/list-student",
                default_params={"pageIndex": 1, "pageSize": 15},
                description="L·∫•y danh s√°ch h·ªçc sinh"
            )
        }
    
    @classmethod
    def get_endpoints(cls) -> Dict[str, 'APIEndpoint']:
        """L·∫•y t·∫•t c·∫£ endpoints (lazy loading)"""
        return cls._build_endpoints()
    
    # Default request settings
    DEFAULT_TIMEOUT = 30
    DEFAULT_HEADERS = {
        "Content-Type": "application/json",
        "Accept": "application/json, text/plain, */*",
        "Accept-Language": "vi-VN,vi;q=0.9,en;q=0.8",
        "Accept-Encoding": "gzip, deflate, br",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Origin": "https://onluyen.vn",
        "Referer": "https://onluyen.vn/"
    }
    
    @classmethod
    def get_endpoint(cls, name: str) -> Optional[APIEndpoint]:
        """
        L·∫•y th√¥ng tin endpoint theo t√™n
        
        Args:
            name (str): T√™n endpoint
            
        Returns:
            Optional[APIEndpoint]: Th√¥ng tin endpoint ho·∫∑c None
        """
        endpoints = cls.get_endpoints()
        return endpoints.get(name)
    
    @classmethod
    def get_all_endpoints(cls) -> Dict[str, APIEndpoint]:
        """
        L·∫•y t·∫•t c·∫£ endpoints
        
        Returns:
            Dict[str, APIEndpoint]: Dictionary ch·ª©a t·∫•t c·∫£ endpoints
        """
        return cls.get_endpoints().copy()
    
    @classmethod
    def print_endpoints_summary(cls):
        """In t√≥m t·∫Øt t·∫•t c·∫£ endpoints"""
        print("üåê ONLUYEN API ENDPOINTS CONFIGURATION")
        print("=" * 60)
        
        endpoints = cls.get_endpoints()
        for name, endpoint in endpoints.items():
            print(f"\nüìã {endpoint.name.upper()}:")
            print(f"   üîß Method: {endpoint.method}")
            print(f"   üîó URL: {endpoint.url}")
            if endpoint.default_params:
                print(f"   üìä Default Params: {endpoint.default_params}")
            print(f"   üìù Description: {endpoint.description}")
    
    @classmethod
    def validate_endpoints(cls) -> Dict[str, bool]:
        """
        Validate t·∫•t c·∫£ endpoints (check URL format)
        
        Returns:
            Dict[str, bool]: K·∫øt qu·∫£ validation cho t·ª´ng endpoint
        """
        results = {}
        endpoints = cls.get_endpoints()
        
        for name, endpoint in endpoints.items():
            try:
                # Simple URL validation
                if endpoint.url.startswith(('http://', 'https://')):
                    results[name] = True
                else:
                    results[name] = False
            except Exception:
                results[name] = False
        
        return results


class OnLuyenAPIClient:
    """Client ƒë·ªÉ g·ªçi OnLuyen APIs"""
    
    def __init__(self, session: requests.Session = None):
        """
        Kh·ªüi t·∫°o API client
        
        Args:
            session (requests.Session, optional): Session ƒë·ªÉ s·ª≠ d·ª•ng
        """
        self.session = session or requests.Session()
        self.session.headers.update(OnLuyenAPIConfig.DEFAULT_HEADERS)
        # T·∫°m th·ªùi b·ªè qua SSL verification cho testing
        self.session.verify = False
        # T·∫Øt c·∫£nh b√°o SSL
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        self.auth_token = None
        
        # ƒê·∫£m b·∫£o environment variables ƒë∆∞·ª£c load
        self._ensure_env_loaded()
    
    def _ensure_env_loaded(self):
        """ƒê·∫£m b·∫£o environment variables ƒë∆∞·ª£c load t·ª´ .env"""
        # Ki·ªÉm tra xem c√≥ c·∫ßn load .env kh√¥ng
        if not os.getenv('ONLUYEN_AUTH_BASE_URL'):
            self._load_env_file()
    
    def _load_env_file(self):
        """Load environment variables t·ª´ .env file"""
        from pathlib import Path
        env_file = Path('.env')
        if env_file.exists():
            with open(env_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        os.environ[key] = value
            print(f"‚úÖ OnLuyenAPIClient: Loaded .env file")
        else:
            print(f"‚ùå OnLuyenAPIClient: .env file not found")
    
    def _log_request_debug(self, method: str, url: str, payload: dict, headers: dict):
        """Log request details cho debug"""
        print(f"\nüîç DEBUG REQUEST:")
        print(f"   Method: {method}")
        print(f"   URL: {url}")
        print(f"   Headers:")
        for key, value in headers.items():
            print(f"     {key}: {value}")
        print(f"   Payload:")
        for key, value in payload.items():
            # ·∫®n password
            if key == "password":
                value = "*" * len(str(value))
            print(f"     {key}: {value}")
        print("=" * 50)
        
    def set_auth_token(self, token: str):
        """
        ƒê·∫∑t auth token cho requests
        
        Args:
            token (str): Auth token
        """
        self.auth_token = token
        self.session.headers["Authorization"] = f"Bearer {token}"
    
    def login(self, username: str, password: str) -> Dict[str, Any]:
        """
        Th·ª±c hi·ªán login
        
        Args:
            username (str): T√™n ƒëƒÉng nh·∫≠p
            password (str): M·∫≠t kh·∫©u
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ login
        """
        endpoint = OnLuyenAPIConfig.get_endpoint("login")
        
        payload = {
            "codeApp": "SCHOOL",
            "password": password,
            "rememberMe": True,
            "userName": username
        }
        
        # Debug logging
        self._log_request_debug(
            method=endpoint.method,
            url=endpoint.url,
            payload=payload,
            headers=self.session.headers
        )
        
        try:
            response = self.session.request(
                method=endpoint.method,
                url=endpoint.url,
                json=payload,
                timeout=OnLuyenAPIConfig.DEFAULT_TIMEOUT
            )
            
            print(f"\nüì° RESPONSE DEBUG:")
            print(f"   Status Code: {response.status_code}")
            print(f"   Headers: {dict(response.headers)}")
            print(f"   Content Length: {len(response.content)} bytes")
            
            # X·ª≠ l√Ω response content v·ªõi decompression
            response_data = None
            if response.content:
                try:
                    # Ki·ªÉm tra content encoding
                    content_encoding = response.headers.get('content-encoding', '').lower()
                    
                    if content_encoding == 'br':
                        # X·ª≠ l√Ω Brotli compression
                        try:
                            import brotli
                            decompressed_content = brotli.decompress(response.content)
                            response_text = decompressed_content.decode('utf-8')
                            print(f"   ‚úÖ Brotli decompressed successfully")
                        except ImportError:
                            print(f"   ‚ùå Brotli library not available")
                            # Fallback: try to decode as-is
                            response_text = response.text
                        except Exception as e:
                            print(f"   ‚ùå Brotli decompression failed: {e}")
                            response_text = response.text
                    elif content_encoding == 'gzip':
                        # Requests t·ª± ƒë·ªông x·ª≠ l√Ω gzip
                        response_text = response.text
                        print(f"   ‚úÖ Gzip handled automatically")
                    else:
                        # Kh√¥ng c√≥ compression ho·∫∑c compression kh√°c
                        response_text = response.text
                        print(f"   ‚úÖ No compression or auto-handled")
                    
                    print(f"   Decoded Content: {response_text[:200]}...")
                    response_data = json.loads(response_text)
                    print(f"   Response JSON Keys: {list(response_data.keys()) if isinstance(response_data, dict) else 'Not a dict'}")
                        
                except json.JSONDecodeError as e:
                    print(f"   JSON Parse Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
                except Exception as e:
                    print(f"   Content Processing Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
            
            result = {
                "success": response.status_code == 200,
                "status_code": response.status_code,
                "data": response_data,
                "error": None
            }
            
            # T·ª± ƒë·ªông set token n·∫øu login th√†nh c√¥ng
            if result["success"] and result["data"]:
                token = result["data"].get("token") or result["data"].get("access_token")
                if token:
                    self.set_auth_token(token)
            
            return result
            
        except Exception as e:
            return {
                "success": False,
                "status_code": None,
                "data": None,
                "error": str(e)
            }
    
    def get_teachers(self, page_size: int = 10, **kwargs) -> Dict[str, Any]:
        """
        L·∫•y danh s√°ch gi√°o vi√™n
        
        Args:
            page_size (int): S·ªë l∆∞·ª£ng records m·ªói page
            **kwargs: C√°c parameters kh√°c
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ API call
        """
        endpoint = OnLuyenAPIConfig.get_endpoint("list_teacher")
        
        params = endpoint.default_params.copy()
        params["pageSize"] = page_size
        params.update(kwargs)
        
        return self._make_request(endpoint, params=params)
    
    def get_students(self, page_index: int = 1, page_size: int = 15, **kwargs) -> Dict[str, Any]:
        """
        L·∫•y danh s√°ch h·ªçc sinh
        
        Args:
            page_index (int): Ch·ªâ s·ªë trang
            page_size (int): S·ªë l∆∞·ª£ng records m·ªói page
            **kwargs: C√°c parameters kh√°c
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ API call
        """
        endpoint = OnLuyenAPIConfig.get_endpoint("list_student")
        
        params = endpoint.default_params.copy()
        params["pageIndex"] = page_index
        params["pageSize"] = page_size
        params.update(kwargs)
        
        return self._make_request(endpoint, params=params)
    
    def _make_request(self, endpoint: APIEndpoint, params: Dict = None, 
                     json_data: Dict = None) -> Dict[str, Any]:
        """
        Th·ª±c hi·ªán API request v·ªõi h·ªó tr·ª£ decompression
        
        Args:
            endpoint (APIEndpoint): Endpoint info
            params (Dict, optional): URL parameters
            json_data (Dict, optional): JSON payload
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ API call
        """
        try:
            print(f"\nüîç API REQUEST DEBUG:")
            print(f"   Method: {endpoint.method}")
            print(f"   URL: {endpoint.url}")
            print(f"   Params: {params}")
            print(f"   Auth Token: {'Set' if self.auth_token else 'Not set'}")
            
            response = self.session.request(
                method=endpoint.method,
                url=endpoint.url,
                params=params,
                json=json_data,
                timeout=OnLuyenAPIConfig.DEFAULT_TIMEOUT
            )
            
            print(f"\nüì° API RESPONSE DEBUG:")
            print(f"   Status Code: {response.status_code}")
            print(f"   Headers: {dict(response.headers)}")
            print(f"   Content Length: {len(response.content)} bytes")
            
            # X·ª≠ l√Ω decompression v√† response data
            response_data = None
            if response.content:
                try:
                    # Ki·ªÉm tra content encoding
                    content_encoding = response.headers.get('content-encoding', '').lower()
                    
                    if content_encoding == 'br':
                        # X·ª≠ l√Ω Brotli compression
                        try:
                            import brotli
                            decompressed_content = brotli.decompress(response.content)
                            response_text = decompressed_content.decode('utf-8')
                            print(f"   ‚úÖ Brotli decompressed successfully")
                        except ImportError:
                            print(f"   ‚ùå Brotli library not available, installing...")
                            # Fallback: try to decode as-is
                            response_text = response.text
                        except Exception as e:
                            print(f"   ‚ùå Brotli decompression failed: {e}")
                            response_text = response.text
                    elif content_encoding == 'gzip':
                        # Requests t·ª± ƒë·ªông x·ª≠ l√Ω gzip
                        response_text = response.text
                        print(f"   ‚úÖ Gzip handled automatically by requests")
                    else:
                        # Kh√¥ng c√≥ compression ho·∫∑c compression kh√°c
                        response_text = response.text
                        print(f"   ‚úÖ No compression or auto-handled")
                    
                    print(f"   Decoded Content: {response_text[:200]}...")
                    response_data = json.loads(response_text)
                    
                    if isinstance(response_data, dict):
                        print(f"   Response JSON Keys: {list(response_data.keys())}")
                    elif isinstance(response_data, list):
                        print(f"   Response is list with {len(response_data)} items")
                    
                except json.JSONDecodeError as e:
                    print(f"   JSON Parse Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
                except Exception as e:
                    print(f"   Content Processing Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
            
            return {
                "success": response.status_code == 200,
                "status_code": response.status_code,
                "data": response_data,
                "error": None,
                "response": response_text[:500] + "..." if 'response_text' in locals() else None,
                "endpoint": endpoint.name
            }
            
        except Exception as e:
            return {
                "success": False,
                "status_code": None,
                "data": None,
                "error": str(e),
                "endpoint": endpoint.name
            }
    
    def test_connectivity(self) -> Dict[str, Any]:
        """
        Test k·∫øt n·ªëi ƒë·∫øn c√°c endpoints
        
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ test
        """
        results = {}
        
        for name, endpoint in OnLuyenAPIConfig.get_all_endpoints().items():
            if name == "login":
                # Skip login test v√¨ c·∫ßn credentials
                results[name] = {"status": "skipped", "reason": "requires_credentials"}
                continue
            
            try:
                response = self.session.head(
                    url=endpoint.url,
                    timeout=10
                )
                results[name] = {
                    "status": "success" if response.status_code < 500 else "error",
                    "status_code": response.status_code
                }
            except Exception as e:
                results[name] = {
                    "status": "error",
                    "error": str(e)
                }
        
        return results


def print_api_config_summary():
    """In t√≥m t·∫Øt c·∫•u h√¨nh API"""
    print("üåê ONLUYEN API CONFIGURATION SUMMARY")
    print("=" * 70)
    
    print(f"\nüè¢ Base URLs (t·ª´ Environment):")
    print(f"   üîê Auth: {OnLuyenAPIConfig.get_auth_base_url()}")
    print(f"   üè´ School API: {OnLuyenAPIConfig.get_school_api_base_url()}")
    
    print(f"\n‚öôÔ∏è Default Settings:")
    print(f"   ‚è±Ô∏è  Timeout: {OnLuyenAPIConfig.DEFAULT_TIMEOUT}s")
    print(f"   üìã Headers: {OnLuyenAPIConfig.DEFAULT_HEADERS}")
    
    OnLuyenAPIConfig.print_endpoints_summary()
    
    print(f"\n‚úÖ Validation Results:")
    validation_results = OnLuyenAPIConfig.validate_endpoints()
    for name, is_valid in validation_results.items():
        status = "‚úÖ Valid" if is_valid else "‚ùå Invalid"
        print(f"   {name}: {status}")
    
    print(f"\nüîß Environment Variables Used:")
    print(f"   ONLUYEN_AUTH_BASE_URL = {os.getenv('ONLUYEN_AUTH_BASE_URL', 'default: https://auth.onluyen.vn')}")
    print(f"   ONLUYEN_SCHOOL_API_BASE_URL = {os.getenv('ONLUYEN_SCHOOL_API_BASE_URL', 'default: https://school-api.onluyen.vn')}")


if __name__ == "__main__":
    print_api_config_summary()
