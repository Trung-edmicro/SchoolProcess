"""
OnLuyen API Configuration
C·∫•u h√¨nh API endpoints cho h·ªá th·ªëng OnLuyen
Author: Assistant
Date: 2025-07-26
"""

from typing import Dict, Any, Optional
import requests
from dataclasses import dataclass
from urllib.parse import urljoin
import json
import os


@dataclass
class APIEndpoint:
    """ƒê·ªãnh nghƒ©a m·ªôt API endpoint"""
    name: str
    method: str
    url: str
    default_params: Dict[str, Any] = None
    description: str = ""
    
    def __post_init__(self):
        if self.default_params is None:
            self.default_params = {}


class OnLuyenAPIConfig:
    """C·∫•u h√¨nh API cho h·ªá th·ªëng OnLuyen"""
    
    @classmethod
    def get_auth_base_url(cls) -> str:
        """L·∫•y Auth Base URL t·ª´ environment"""
        return os.getenv('ONLUYEN_AUTH_BASE_URL')
    
    @classmethod  
    def get_school_api_base_url(cls) -> str:
        """L·∫•y School API Base URL t·ª´ environment"""
        return os.getenv('ONLUYEN_SCHOOL_API_BASE_URL')
    
    @classmethod
    def _build_endpoints(cls) -> Dict[str, 'APIEndpoint']:
        """Build endpoints v·ªõi URLs t·ª´ environment"""
        auth_base = cls.get_auth_base_url()
        school_api_base = cls.get_school_api_base_url()
        
        return {
            "login": APIEndpoint(
                name="login",
                method="POST", 
                url=f"{auth_base}/api/account/login",
                description="ƒêƒÉng nh·∫≠p t√†i kho·∫£n"
            ),
            
            "change_school_year": APIEndpoint(
                name="change_school_year",
                method="GET",
                url=f"{auth_base}/api/account/change-school-year",
                default_params={"codeApp": "SCHOOL"},
                description="Thay ƒë·ªïi nƒÉm h·ªçc"
            ),
            
            "list_teacher": APIEndpoint(
                name="list_teacher",
                method="GET",
                url=f"{school_api_base}/school/list-teacher/%20/1",
                default_params={"pageSize": 10},
                description="L·∫•y danh s√°ch gi√°o vi√™n"
            ),
            
            "list_student": APIEndpoint(
                name="list_student", 
                method="GET",
                url=f"{school_api_base}/school/list-student",
                default_params={"pageIndex": 1, "pageSize": 15},
                description="L·∫•y danh s√°ch h·ªçc sinh"
            )
        }
    
    @classmethod
    def get_endpoints(cls) -> Dict[str, 'APIEndpoint']:
        """L·∫•y t·∫•t c·∫£ endpoints (lazy loading)"""
        return cls._build_endpoints()
    
    # Default request settings
    DEFAULT_TIMEOUT = 30
    DEFAULT_HEADERS = {
        "Content-Type": "application/json",
        "Accept": "application/json, text/plain, */*",
        "Accept-Language": "vi-VN,vi;q=0.9,en;q=0.8",
        "Accept-Encoding": "gzip, deflate, br",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Origin": "https://onluyen.vn",
        "Referer": "https://onluyen.vn/"
    }
    
    @classmethod
    def get_endpoint(cls, name: str) -> Optional[APIEndpoint]:
        """
        L·∫•y th√¥ng tin endpoint theo t√™n
        
        Args:
            name (str): T√™n endpoint
            
        Returns:
            Optional[APIEndpoint]: Th√¥ng tin endpoint ho·∫∑c None
        """
        endpoints = cls.get_endpoints()
        return endpoints.get(name)
    
    @classmethod
    def get_all_endpoints(cls) -> Dict[str, APIEndpoint]:
        """
        L·∫•y t·∫•t c·∫£ endpoints
        
        Returns:
            Dict[str, APIEndpoint]: Dictionary ch·ª©a t·∫•t c·∫£ endpoints
        """
        return cls.get_endpoints().copy()
    
    @classmethod
    def print_endpoints_summary(cls):
        """In t√≥m t·∫Øt t·∫•t c·∫£ endpoints"""
        print("üåê ONLUYEN API ENDPOINTS CONFIGURATION")
        print("=" * 60)
        
        endpoints = cls.get_endpoints()
        for name, endpoint in endpoints.items():
            print(f"\nüìã {endpoint.name.upper()}:")
            print(f"   üîß Method: {endpoint.method}")
            print(f"   üîó URL: {endpoint.url}")
            if endpoint.default_params:
                print(f"   üìä Default Params: {endpoint.default_params}")
            print(f"   üìù Description: {endpoint.description}")
    
    @classmethod
    def validate_endpoints(cls) -> Dict[str, bool]:
        """
        Validate t·∫•t c·∫£ endpoints (check URL format)
        
        Returns:
            Dict[str, bool]: K·∫øt qu·∫£ validation cho t·ª´ng endpoint
        """
        results = {}
        endpoints = cls.get_endpoints()
        
        for name, endpoint in endpoints.items():
            try:
                # Simple URL validation
                if endpoint.url.startswith(('http://', 'https://')):
                    results[name] = True
                else:
                    results[name] = False
            except Exception:
                results[name] = False
        
        return results


class OnLuyenAPIClient:
    """Client ƒë·ªÉ g·ªçi OnLuyen APIs"""
    
    def __init__(self, session: requests.Session = None):
        """
        Kh·ªüi t·∫°o API client
        
        Args:
            session (requests.Session, optional): Session ƒë·ªÉ s·ª≠ d·ª•ng
        """
        self.session = session or requests.Session()
        self.session.headers.update(OnLuyenAPIConfig.DEFAULT_HEADERS)
        # T·∫°m th·ªùi b·ªè qua SSL verification cho testing
        self.session.verify = False
        # T·∫Øt c·∫£nh b√°o SSL
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        self.auth_token = None
        
        # ƒê·∫£m b·∫£o environment variables ƒë∆∞·ª£c load
        self._ensure_env_loaded()
    
    def _ensure_env_loaded(self):
        """ƒê·∫£m b·∫£o environment variables ƒë∆∞·ª£c load t·ª´ .env"""
        # Ki·ªÉm tra xem c√≥ c·∫ßn load .env kh√¥ng
        if not os.getenv('ONLUYEN_AUTH_BASE_URL'):
            self._load_env_file()
    
    def _load_env_file(self):
        """Load environment variables t·ª´ .env file"""
        from pathlib import Path
        env_file = Path('.env')
        if env_file.exists():
            with open(env_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        os.environ[key] = value
            print(f"‚úÖ OnLuyenAPIClient: Loaded .env file")
        else:
            print(f"‚ùå OnLuyenAPIClient: .env file not found")
    
    def _log_request_debug(self, method: str, url: str, payload: dict, headers: dict):
        """Log request details cho debug"""
        print(f"\nüîç DEBUG REQUEST:")
        print(f"   Method: {method}")
        print(f"   URL: {url}")
        print(f"   Headers:")
        for key, value in headers.items():
            print(f"     {key}: {value}")
        print(f"   Payload:")
        for key, value in payload.items():
            # ·∫®n password
            if key == "password":
                value = "*" * len(str(value))
            print(f"     {key}: {value}")
        print("=" * 50)
        
    def set_auth_token(self, token: str):
        """
        ƒê·∫∑t auth token cho requests
        
        Args:
            token (str): Auth token
        """
        self.auth_token = token
        self.session.headers["Authorization"] = f"Bearer {token}"
    
    def login(self, username: str, password: str) -> Dict[str, Any]:
        """
        Th·ª±c hi·ªán login
        
        Args:
            username (str): T√™n ƒëƒÉng nh·∫≠p
            password (str): M·∫≠t kh·∫©u
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ login
        """
        endpoint = OnLuyenAPIConfig.get_endpoint("login")
        
        payload = {
            "codeApp": "SCHOOL",
            "password": password,
            "rememberMe": True,
            "userName": username
        }
        
        # Debug logging
        self._log_request_debug(
            method=endpoint.method,
            url=endpoint.url,
            payload=payload,
            headers=self.session.headers
        )
        
        try:
            response = self.session.request(
                method=endpoint.method,
                url=endpoint.url,
                json=payload,
                timeout=OnLuyenAPIConfig.DEFAULT_TIMEOUT
            )
            
            print(f"\nüì° RESPONSE DEBUG:")
            print(f"   Status Code: {response.status_code}")
            print(f"   Headers: {dict(response.headers)}")
            print(f"   Content Length: {len(response.content)} bytes")
            
            # X·ª≠ l√Ω response content v·ªõi decompression
            response_data = None
            if response.content:
                try:
                    # Ki·ªÉm tra content encoding
                    content_encoding = response.headers.get('content-encoding', '').lower()
                    
                    if content_encoding == 'br':
                        # X·ª≠ l√Ω Brotli compression
                        try:
                            import brotli
                            decompressed_content = brotli.decompress(response.content)
                            response_text = decompressed_content.decode('utf-8')
                            print(f"   ‚úÖ Brotli decompressed successfully")
                        except ImportError:
                            print(f"   ‚ùå Brotli library not available")
                            # Fallback: try to decode as-is
                            response_text = response.text
                        except Exception as e:
                            print(f"   ‚ùå Brotli decompression failed: {e}")
                            response_text = response.text
                    elif content_encoding == 'gzip':
                        # Requests t·ª± ƒë·ªông x·ª≠ l√Ω gzip
                        response_text = response.text
                        print(f"   ‚úÖ Gzip handled automatically")
                    else:
                        # Kh√¥ng c√≥ compression ho·∫∑c compression kh√°c
                        response_text = response.text
                        print(f"   ‚úÖ No compression or auto-handled")
                    
                    print(f"   Decoded Content: {response_text[:200]}...")
                    response_data = json.loads(response_text)
                    print(f"   Response JSON Keys: {list(response_data.keys()) if isinstance(response_data, dict) else 'Not a dict'}")
                        
                except json.JSONDecodeError as e:
                    print(f"   JSON Parse Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
                except Exception as e:
                    print(f"   Content Processing Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
            
            result = {
                "success": response.status_code == 200,
                "status_code": response.status_code,
                "data": response_data,
                "error": None
            }
            
            # T·ª± ƒë·ªông set token n·∫øu login th√†nh c√¥ng
            if result["success"] and result["data"]:
                token = result["data"].get("access_token")
                if token:
                    self.set_auth_token(token)
                    print(f"‚úÖ Access token automatically set after login")
            
            return result
            
        except Exception as e:
            return {
                "success": False,
                "status_code": None,
                "data": None,
                "error": str(e)
            }
    
    def change_year_v2(self, year: int, save_to_login_file: bool = True, login_file_path: str = None) -> Dict[str, Any]:
        """
        Thay ƒë·ªïi nƒÉm h·ªçc b·∫±ng endpoint ch√≠nh x√°c t·ª´ browser headers
        
        Args:
            year (int): NƒÉm h·ªçc m·ªõi (v√≠ d·ª•: 2024, 2025)
            save_to_login_file (bool): C√≥ l∆∞u access_token m·ªõi v√†o file login kh√¥ng
            login_file_path (str, optional): ƒê∆∞·ªùng d·∫´n file login JSON ƒë·ªÉ update
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ thay ƒë·ªïi nƒÉm h·ªçc
        """
        if not self.auth_token:
            return {
                "success": False,
                "error": "Ch∆∞a c√≥ access_token. Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi thay ƒë·ªïi nƒÉm h·ªçc",
                "status_code": None,
                "data": None
            }
        
        # S·ª≠ d·ª•ng endpoint ch√≠nh x√°c t·ª´ browser headers
        url = f"https://oauth.onluyen.vn/api/account/change-school-year/{year}"
        params = {'codeApp': 'SCHOOL'}
        
        headers = {
            'Authorization': f'Bearer {self.auth_token}',
            'Content-Type': 'application/json',
            'Origin': 'https://school.onluyen.vn',
            'Referer': 'https://school.onluyen.vn/',
            'Accept': 'application/json, text/plain, */*',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        print(f"\nüìÖ Changing school year to: {year}")
        print(f"   üìç URL: {url}")
        print(f"   üìã Params: {params}")
        print(f"   üîê Headers: {list(headers.keys())}")
        
        try:
            response = requests.post(url, headers=headers, params=params, timeout=30)
            result = self._process_response(response)
            
            # N·∫øu th√†nh c√¥ng v√† c√≥ access_token m·ªõi, l∆∞u v√†o file login
            if result["success"] and save_to_login_file and result.get("data"):
                self._update_login_file_with_new_token(result["data"], login_file_path, year)
            
            return result
            
        except Exception as e:
            return {
                "success": False,
                "error": f"L·ªói khi thay ƒë·ªïi nƒÉm h·ªçc: {str(e)}",
                "status_code": None,
                "data": None
            }

    def change_year(self, year: int, save_to_login_file: bool = True, login_file_path: str = None) -> Dict[str, Any]:
        """
        Thay ƒë·ªïi nƒÉm h·ªçc s·ª≠ d·ª•ng access_token ƒë·ªÉ x√°c th·ª±c
        
        Args:
            year (int): NƒÉm h·ªçc m·ªõi (v√≠ d·ª•: 2024, 2025)
            save_to_login_file (bool): C√≥ l∆∞u access_token m·ªõi v√†o file login kh√¥ng
            login_file_path (str, optional): ƒê∆∞·ªùng d·∫´n file login JSON ƒë·ªÉ update
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ thay ƒë·ªïi nƒÉm h·ªçc
        """
        if not self.auth_token:
            return {
                "success": False,
                "error": "Ch∆∞a c√≥ access_token. Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi thay ƒë·ªïi nƒÉm h·ªçc",
                "status_code": None,
                "data": None
            }
        
        # Th·ª≠ nhi·ªÅu endpoint URLs v√† methods kh√°c nhau
        possible_configs = [
            # Th·ª≠ v·ªõi GET method
            {"url": f"{self.get_school_api_base_url()}/api/account/change-school-year", "method": "GET"},
            {"url": f"{self.get_auth_base_url()}/api/account/change-school-year", "method": "GET"},
            {"url": f"{self.get_school_api_base_url()}/account/change-school-year", "method": "GET"},
            {"url": f"{self.get_auth_base_url()}/account/change-school-year", "method": "GET"},
            {"url": f"{self.get_school_api_base_url()}/api/change-school-year", "method": "GET"},
            {"url": f"{self.get_auth_base_url()}/api/change-school-year", "method": "GET"},
            # Th·ª≠ v·ªõi POST method
            {"url": f"{self.get_school_api_base_url()}/api/account/change-school-year", "method": "POST"},
            {"url": f"{self.get_auth_base_url()}/api/account/change-school-year", "method": "POST"},
            {"url": f"{self.get_school_api_base_url()}/account/change-school-year", "method": "POST"},
            {"url": f"{self.get_auth_base_url()}/account/change-school-year", "method": "POST"},
        ]
        
        print(f"\nüìÖ Trying to change school year to: {year}")
        
        for i, config in enumerate(possible_configs, 1):
            print(f"\nüîÑ Attempt {i}/{len(possible_configs)}")
            
            # T·∫°o URL v·ªõi year parameter
            url_with_year = f"{config['url']}/{year}"
            
            # T·∫°o endpoint t·∫°m th·ªùi v·ªõi URL ƒë√£ c√≥ year
            temp_endpoint = APIEndpoint(
                name="change_school_year",
                method="GET",
                url=url_with_year,
                default_params={"codeApp": "SCHOOL"},
                description="Thay ƒë·ªïi nƒÉm h·ªçc"
            )
            
            # G·ªçi API v·ªõi codeApp parameter
            params = {"codeApp": "SCHOOL"}
            
            print(f"   üìç URL: {url_with_year}")
            print(f"   üìã Params: {params}")
            
            result = self._make_request(temp_endpoint, params=params)
            
            # N·∫øu kh√¥ng ph·∫£i l·ªói 404, return k·∫øt qu·∫£ (d√π th√†nh c√¥ng hay th·∫•t b·∫°i)
            if result.get("status_code") != 404:
                print(f"   ‚úÖ Found working endpoint: {config['url']}")
                
                # N·∫øu th√†nh c√¥ng v√† c√≥ access_token m·ªõi, l∆∞u v√†o file login
                if result["success"] and save_to_login_file and result.get("data"):
                    self._update_login_file_with_new_token(result["data"], login_file_path, year)
                
                return result
            else:
                print(f"   ‚ùå 404 - Endpoint not found")
        
        # N·∫øu t·∫•t c·∫£ endpoints ƒë·ªÅu tr·∫£ v·ªÅ 404
        return {
            "success": False,
            "error": f"Kh√¥ng t√¨m th·∫•y endpoint thay ƒë·ªïi nƒÉm h·ªçc. ƒê√£ th·ª≠ {len(possible_configs)} URLs kh√°c nhau.",
            "status_code": 404,
            "data": None
        }
    
    def _update_login_file_with_new_token(self, response_data: Dict[str, Any], 
                                        login_file_path: str = None, year: int = None):
        """
        C·∫≠p nh·∫≠t file login JSON v·ªõi access_token m·ªõi sau khi thay ƒë·ªïi nƒÉm h·ªçc
        
        Args:
            response_data (Dict): Response data t·ª´ API change_year
            login_file_path (str, optional): ƒê∆∞·ªùng d·∫´n file login c·ª• th·ªÉ
            year (int, optional): NƒÉm h·ªçc ƒë√£ thay ƒë·ªïi
        """
        try:
            # T√¨m file login g·∫ßn nh·∫•t n·∫øu kh√¥ng ch·ªâ ƒë·ªãnh
            if not login_file_path:
                login_file_path = self._find_latest_login_file()
            
            if not login_file_path:
                print("‚ùå Kh√¥ng t√¨m th·∫•y file login ƒë·ªÉ c·∫≠p nh·∫≠t")
                return
            
            # ƒê·ªçc file login hi·ªán t·∫°i
            with open(login_file_path, 'r', encoding='utf-8') as f:
                login_data = json.load(f)
            
            # C·∫≠p nh·∫≠t tokens n·∫øu c√≥ trong response
            if "access_token" in response_data:
                login_data["tokens"]["access_token"] = response_data["access_token"]
                print(f"‚úÖ Updated access_token in login file")
            
            if "refresh_token" in response_data:
                login_data["tokens"]["refresh_token"] = response_data["refresh_token"]
                print(f"‚úÖ Updated refresh_token in login file")
            
            if "expires_in" in response_data:
                login_data["tokens"]["expires_in"] = response_data["expires_in"]
                print(f"‚úÖ Updated expires_in in login file")
            
            if "expires_at" in response_data:
                login_data["tokens"]["expires_at"] = response_data["expires_at"]
                print(f"‚úÖ Updated expires_at in login file")
            
            # Th√™m th√¥ng tin v·ªÅ vi·ªác thay ƒë·ªïi nƒÉm h·ªçc
            if year:
                login_data["last_year_change"] = {
                    "year": year,
                    "timestamp": self._get_current_timestamp(),
                    "status": "success"
                }
                print(f"‚úÖ Added year change info: {year}")
            
            # L∆∞u l·∫°i file
            with open(login_file_path, 'w', encoding='utf-8') as f:
                json.dump(login_data, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ Login file updated successfully: {login_file_path}")
            
        except Exception as e:
            print(f"‚ùå Error updating login file: {e}")
    
    def _find_latest_login_file(self) -> str:
        """
        T√¨m file login g·∫ßn nh·∫•t trong th∆∞ m·ª•c output
        
        Returns:
            str: ƒê∆∞·ªùng d·∫´n file login g·∫ßn nh·∫•t ho·∫∑c None
        """
        try:
            import glob
            from pathlib import Path
            
            # T√¨m t·∫•t c·∫£ file login trong th∆∞ m·ª•c output
            output_dir = Path("data/output")
            login_pattern = output_dir / "onluyen_login_*.json"
            login_files = glob.glob(str(login_pattern))
            
            if not login_files:
                return None
            
            # S·∫Øp x·∫øp theo th·ªùi gian modified v√† l·∫•y file m·ªõi nh·∫•t
            latest_file = max(login_files, key=os.path.getmtime)
            print(f"üìÅ Found latest login file: {latest_file}")
            return latest_file
            
        except Exception as e:
            print(f"‚ùå Error finding login file: {e}")
            return None
    
    def _get_current_timestamp(self) -> str:
        """
        L·∫•y timestamp hi·ªán t·∫°i theo format c·ªßa h·ªá th·ªëng
        
        Returns:
            str: Timestamp string
        """
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def load_token_from_login_file(self, login_file_path: str = None) -> bool:
        """
        Load access_token t·ª´ file login JSON
        
        Args:
            login_file_path (str, optional): ƒê∆∞·ªùng d·∫´n file login c·ª• th·ªÉ.
                                           N·∫øu None, s·∫Ω t√¨m file login g·∫ßn nh·∫•t
            
        Returns:
            bool: True n·∫øu load th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        try:
            # T√¨m file login g·∫ßn nh·∫•t n·∫øu kh√¥ng ch·ªâ ƒë·ªãnh
            if not login_file_path:
                login_file_path = self._find_latest_login_file()
            
            if not login_file_path:
                print("‚ùå Kh√¥ng t√¨m th·∫•y file login ƒë·ªÉ load token")
                return False
            
            # ƒê·ªçc file login
            with open(login_file_path, 'r', encoding='utf-8') as f:
                login_data = json.load(f)
            
            # L·∫•y access_token
            access_token = login_data.get("tokens", {}).get("access_token")
            if access_token:
                self.set_auth_token(access_token)
                print(f"‚úÖ Access token loaded from: {login_file_path}")
                print(f"   Token: {access_token[:20]}...")
                return True
            else:
                print("‚ùå Kh√¥ng t√¨m th·∫•y access_token trong file login")
                return False
                
        except Exception as e:
            print(f"‚ùå Error loading token from login file: {e}")
            return False
    
    def get_current_school_year_info(self) -> Dict[str, Any]:
        """
        L·∫•y th√¥ng tin nƒÉm h·ªçc hi·ªán t·∫°i t·ª´ access_token
        
        Returns:
            Dict[str, Any]: Th√¥ng tin nƒÉm h·ªçc v√† user
        """
        try:
            if not self.auth_token:
                # Th·ª≠ load token t·ª´ file login
                if not self.load_token_from_login_file():
                    return {"success": False, "error": "Kh√¥ng c√≥ access token"}
            
            # Decode JWT token manually (ch·ªâ l·∫•y payload, kh√¥ng verify)
            parts = self.auth_token.split('.')
            if len(parts) >= 2:
                # Decode payload (part 1)
                payload = parts[1]
                # Th√™m padding n·∫øu c·∫ßn
                padding = len(payload) % 4
                if padding:
                    payload += '=' * (4 - padding)
                
                import base64
                import json
                decoded_bytes = base64.b64decode(payload)
                decoded = json.loads(decoded_bytes.decode('utf-8'))
                
                school_year = decoded.get('SchoolYear')
                display_name = decoded.get('DisplayName', '')
                email = decoded.get('Email', '')
                
                return {
                    "success": True,
                    "school_year": school_year,
                    "display_name": display_name,
                    "email": email,
                    "decoded_payload": decoded
                }
            else:
                return {"success": False, "error": "Invalid token format"}
                
        except Exception as e:
            return {"success": False, "error": f"L·ªói decode token: {str(e)}"}
    
    def print_current_school_year_info(self):
        """In th√¥ng tin nƒÉm h·ªçc hi·ªán t·∫°i"""
        info = self.get_current_school_year_info()
        
        if info["success"]:
            print(f"\nüìÖ TH√îNG TIN NƒÇM H·ªåC HI·ªÜN T·∫†I:")
            if info.get("school_year"):
                print(f"   üìö NƒÉm h·ªçc: {info['school_year']}")
            if info.get("display_name"):
                print(f"   üë§ T√†i kho·∫£n: {info['display_name']}")
            if info.get("email"):
                print(f"   üìß Email: {info['email']}")
        else:
            print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin nƒÉm h·ªçc: {info.get('error')}")

    def switch_school_year(self, target_year: int = None, save_to_login_file: bool = True, 
                         login_file_path: str = None) -> Dict[str, Any]:
        """
        Chuy·ªÉn ƒë·ªïi nƒÉm h·ªçc gi·ªØa 2024 v√† 2025
        
        Args:
            target_year (int, optional): NƒÉm h·ªçc mu·ªën chuy·ªÉn ƒë·∫øn. 
                                       N·∫øu None, s·∫Ω t·ª± ƒë·ªông chuy·ªÉn ƒë·ªïi gi·ªØa 2024-2025
            save_to_login_file (bool): C√≥ l∆∞u access_token m·ªõi v√†o file login kh√¥ng
            login_file_path (str, optional): ƒê∆∞·ªùng d·∫´n file login JSON ƒë·ªÉ update
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ thay ƒë·ªïi nƒÉm h·ªçc
        """
        if target_year is None:
            # T·ª± ƒë·ªông chuy·ªÉn ƒë·ªïi - m·∫∑c ƒë·ªãnh chuy·ªÉn sang 2025
            target_year = 2025
            print(f"üìÖ Auto-switching to school year: {target_year}")
        
        if target_year not in [2024, 2025]:
            return {
                "success": False,
                "error": f"NƒÉm h·ªçc kh√¥ng h·ª£p l·ªá: {target_year}. Ch·ªâ h·ªó tr·ª£ 2024 ho·∫∑c 2025",
                "status_code": None,
                "data": None
            }
        
        return self.change_year(target_year, save_to_login_file, login_file_path)

    def get_teachers(self, page_size: int = 10, **kwargs) -> Dict[str, Any]:
        """
        L·∫•y danh s√°ch gi√°o vi√™n
        
        Args:
            page_size (int): S·ªë l∆∞·ª£ng records m·ªói page
            **kwargs: C√°c parameters kh√°c
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ API call
        """
        endpoint = OnLuyenAPIConfig.get_endpoint("list_teacher")
        
        params = endpoint.default_params.copy()
        params["pageSize"] = page_size
        params.update(kwargs)
        
        return self._make_request(endpoint, params=params)
    
    def get_students(self, page_index: int = 1, page_size: int = 15, **kwargs) -> Dict[str, Any]:
        """
        L·∫•y danh s√°ch h·ªçc sinh
        
        Args:
            page_index (int): Ch·ªâ s·ªë trang
            page_size (int): S·ªë l∆∞·ª£ng records m·ªói page
            **kwargs: C√°c parameters kh√°c
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ API call
        """
        endpoint = OnLuyenAPIConfig.get_endpoint("list_student")
        
        params = endpoint.default_params.copy()
        params["pageIndex"] = page_index
        params["pageSize"] = page_size
        params.update(kwargs)
        
        return self._make_request(endpoint, params=params)
    
    def _make_request(self, endpoint: APIEndpoint, params: Dict = None, 
                     json_data: Dict = None) -> Dict[str, Any]:
        """
        Th·ª±c hi·ªán API request v·ªõi h·ªó tr·ª£ decompression
        
        Args:
            endpoint (APIEndpoint): Endpoint info
            params (Dict, optional): URL parameters
            json_data (Dict, optional): JSON payload
            
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ API call
        """
        try:
            print(f"\nüîç API REQUEST DEBUG:")
            print(f"   Method: {endpoint.method}")
            print(f"   URL: {endpoint.url}")
            print(f"   Params: {params}")
            print(f"   Auth Token: {'Set' if self.auth_token else 'Not set'}")
            
            response = self.session.request(
                method=endpoint.method,
                url=endpoint.url,
                params=params,
                json=json_data,
                timeout=OnLuyenAPIConfig.DEFAULT_TIMEOUT
            )
            
            print(f"\nüì° API RESPONSE DEBUG:")
            print(f"   Status Code: {response.status_code}")
            print(f"   Headers: {dict(response.headers)}")
            print(f"   Content Length: {len(response.content)} bytes")
            
            # X·ª≠ l√Ω decompression v√† response data
            response_data = None
            if response.content:
                try:
                    # Ki·ªÉm tra content encoding
                    content_encoding = response.headers.get('content-encoding', '').lower()
                    
                    if content_encoding == 'br':
                        # X·ª≠ l√Ω Brotli compression
                        try:
                            import brotli
                            decompressed_content = brotli.decompress(response.content)
                            response_text = decompressed_content.decode('utf-8')
                            print(f"   ‚úÖ Brotli decompressed successfully")
                        except ImportError:
                            print(f"   ‚ùå Brotli library not available, installing...")
                            # Fallback: try to decode as-is
                            response_text = response.text
                        except Exception as e:
                            print(f"   ‚ùå Brotli decompression failed: {e}")
                            response_text = response.text
                    elif content_encoding == 'gzip':
                        # Requests t·ª± ƒë·ªông x·ª≠ l√Ω gzip
                        response_text = response.text
                        print(f"   ‚úÖ Gzip handled automatically by requests")
                    else:
                        # Kh√¥ng c√≥ compression ho·∫∑c compression kh√°c
                        response_text = response.text
                        print(f"   ‚úÖ No compression or auto-handled")
                    
                    print(f"   Decoded Content: {response_text[:200]}...")
                    response_data = json.loads(response_text)
                    
                    if isinstance(response_data, dict):
                        print(f"   Response JSON Keys: {list(response_data.keys())}")
                    elif isinstance(response_data, list):
                        print(f"   Response is list with {len(response_data)} items")
                    
                except json.JSONDecodeError as e:
                    print(f"   JSON Parse Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
                except Exception as e:
                    print(f"   Content Processing Error: {e}")
                    print(f"   Raw Content (first 200): {response.content[:200]}")
                    response_data = None
            
            return {
                "success": response.status_code == 200,
                "status_code": response.status_code,
                "data": response_data,
                "error": None,
                "response": response_text[:500] + "..." if 'response_text' in locals() else None,
                "endpoint": endpoint.name
            }
            
        except Exception as e:
            return {
                "success": False,
                "status_code": None,
                "data": None,
                "error": str(e),
                "endpoint": endpoint.name
            }
    
    def test_connectivity(self) -> Dict[str, Any]:
        """
        Test k·∫øt n·ªëi ƒë·∫øn c√°c endpoints
        
        Returns:
            Dict[str, Any]: K·∫øt qu·∫£ test
        """
        results = {}
        
        for name, endpoint in OnLuyenAPIConfig.get_all_endpoints().items():
            if name == "login":
                # Skip login test v√¨ c·∫ßn credentials
                results[name] = {"status": "skipped", "reason": "requires_credentials"}
                continue
            
            try:
                response = self.session.head(
                    url=endpoint.url,
                    timeout=10
                )
                results[name] = {
                    "status": "success" if response.status_code < 500 else "error",
                    "status_code": response.status_code
                }
            except Exception as e:
                results[name] = {
                    "status": "error",
                    "error": str(e)
                }
        
        return results


def print_api_config_summary():
    """In t√≥m t·∫Øt c·∫•u h√¨nh API"""
    print("üåê ONLUYEN API CONFIGURATION SUMMARY")
    print("=" * 70)
    
    print(f"\nüè¢ Base URLs (t·ª´ Environment):")
    print(f"   üîê Auth: {OnLuyenAPIConfig.get_auth_base_url()}")
    print(f"   üè´ School API: {OnLuyenAPIConfig.get_school_api_base_url()}")
    
    print(f"\n‚öôÔ∏è Default Settings:")
    print(f"   ‚è±Ô∏è  Timeout: {OnLuyenAPIConfig.DEFAULT_TIMEOUT}s")
    print(f"   üìã Headers: {OnLuyenAPIConfig.DEFAULT_HEADERS}")
    
    OnLuyenAPIConfig.print_endpoints_summary()
    
    print(f"\n‚úÖ Validation Results:")
    validation_results = OnLuyenAPIConfig.validate_endpoints()
    for name, is_valid in validation_results.items():
        status = "‚úÖ Valid" if is_valid else "‚ùå Invalid"
        print(f"   {name}: {status}")
    
    print(f"\nüîß Environment Variables Used:")
    print(f"   ONLUYEN_AUTH_BASE_URL = {os.getenv('ONLUYEN_AUTH_BASE_URL', 'default: https://auth.onluyen.vn')}")
    print(f"   ONLUYEN_SCHOOL_API_BASE_URL = {os.getenv('ONLUYEN_SCHOOL_API_BASE_URL', 'default: https://school-api.onluyen.vn')}")


if __name__ == "__main__":
    print_api_config_summary()
