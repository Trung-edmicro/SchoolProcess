import sys
import pandas as pd
from pathlib import Path
from typing import Dict, List, Optional, Any

# Add project root to Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from config.config_manager import get_config
from processors.google_processor import GoogleDataProcessor


class GoogleSheetsExtractor:
    """Class chuy√™n bi·ªát ƒë·ªÉ tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ Google Sheets"""
    
    def __init__(self):
        """Kh·ªüi t·∫°o extractor"""
        self.config = get_config()
        self.processor = None
        self._init_processor()
    
    def _init_processor(self) -> None:
        """Kh·ªüi t·∫°o Google processor"""
        try:
            paths = self.config.get_paths_config()
            self.processor = GoogleDataProcessor(
                input_folder=paths['input_dir'],
                temp_folder=paths['temp_dir'],
                output_folder=paths['output_dir']
            )
        except Exception as e:
            print(f"‚ùå L·ªói kh·ªüi t·∫°o processor: {e}")
            self.processor = None
    
    def extract_required_columns(self, sheet_id: str = None, sheet_name: str = 'ED-2025', 
                                required_columns: List[str] = None) -> Optional[Dict[str, Any]]:
        """
        Tr√≠ch xu·∫•t c√°c c·ªôt c·∫ßn thi·∫øt t·ª´ Google Sheets
        
        Args:
            sheet_id (str): Sheet ID ho·∫∑c URL
            sheet_name (str): T√™n sheet c·ª• th·ªÉ
            required_columns (List[str]): Danh s√°ch t√™n c·ªôt c·∫ßn tr√≠ch xu·∫•t
            
        Returns:
            Optional[Dict[str, Any]]: Dictionary ch·ª©a d·ªØ li·ªáu ƒë√£ tr√≠ch xu·∫•t
        """
        if not self.processor:
            print("‚ùå Processor kh√¥ng kh·∫£ d·ª•ng")
            return None
        
        # S·ª≠ d·ª•ng test sheet n·∫øu kh√¥ng c√≥ input
        if not sheet_id:
            google_config = self.config.get_google_config()
            sheet_id = google_config['test_sheet_id']
        
        # M·∫∑c ƒë·ªãnh c√°c c·ªôt c·∫ßn thi·∫øt
        if not required_columns:
            required_columns = ['T√™n tr∆∞·ªùng', 'Admin', 'M·∫≠t kh·∫©u', 'Link driver d·ªØ li·ªáu']
        
        print(f"üîç TR√çCH XU·∫§T D·ªÆ LI·ªÜU T·ª™ GOOGLE SHEETS")
        print("=" * 60)
        print(f"üìã Sheet ID: {sheet_id}")
        print(f"üìÑ Sheet Name: {sheet_name or 'ED-2025'}")
        print(f"üìä C·ªôt c·∫ßn tr√≠ch xu·∫•t: {', '.join(required_columns)}")
        print()
        
        try:
            # ƒê·ªçc d·ªØ li·ªáu t·ª´ sheet
            print("üîÑ ƒêang ƒë·ªçc d·ªØ li·ªáu...")
            df = self.processor.google_client.read_shared_google_sheet(sheet_id, sheet_name)
            
            if df is None or df.empty:
                print("‚ùå Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c d·ªØ li·ªáu ho·∫∑c sheet tr·ªëng")
                return None
            
            print(f"‚úÖ ƒê√£ ƒë·ªçc {len(df)} h√†ng, {len(df.columns)} c·ªôt")
            
            # X·ª≠ l√Ω header (n·∫øu columns l√† s·ªë th√¨ c·∫ßn mapping)
            if all(isinstance(col, (int, float)) for col in df.columns):
                # N·∫øu columns l√† s·ªë, l·∫•y h√†ng ƒë·∫ßu ti√™n l√†m header
                if len(df) > 0:
                    header_row = df.iloc[0].tolist()
                    df.columns = header_row
                    df = df.iloc[1:].reset_index(drop=True)
                    print(f"üìã ƒê√£ chuy·ªÉn ƒë·ªïi header t·ª´ h√†ng ƒë·∫ßu ti√™n")
            
            print(f"üìã Available columns: {list(df.columns)}")
            
            # T√¨m c√°c c·ªôt c·∫ßn thi·∫øt
            found_columns = {}
            missing_columns = []
            
            for required_col in required_columns:
                # T√¨m exact match tr∆∞·ªõc
                if required_col in df.columns:
                    found_columns[required_col] = required_col
                else:
                    # T√¨m partial match (case insensitive)
                    matched = False
                    for col in df.columns:
                        if str(col).lower().strip() in required_col.lower() or \
                           required_col.lower() in str(col).lower().strip():
                            found_columns[required_col] = col
                            matched = True
                            break
                    
                    if not matched:
                        missing_columns.append(required_col)
            
            print(f"\nüîç K·∫æT QU·∫¢ T√åM KI·∫æM C·ªòT:")
            for req_col, found_col in found_columns.items():
                print(f"   ‚úÖ '{req_col}' ‚Üí '{found_col}'")
            
            for missing_col in missing_columns:
                print(f"   ‚ùå '{missing_col}' ‚Üí Kh√¥ng t√¨m th·∫•y")
            
            if not found_columns:
                print("\n‚ùå Kh√¥ng t√¨m th·∫•y c·ªôt n√†o c·∫ßn thi·∫øt")
                return None
            
            # Tr√≠ch xu·∫•t d·ªØ li·ªáu
            extracted_data = {
                'metadata': {
                    'sheet_id': sheet_id,
                    'sheet_name': sheet_name,
                    'total_rows': len(df),
                    'total_columns': len(df.columns),
                    'found_columns': found_columns,
                    'missing_columns': missing_columns
                },
                'data': []
            }
            
            # L·∫•y d·ªØ li·ªáu t·ª´ c√°c c·ªôt t√¨m ƒë∆∞·ª£c
            for index, row in df.iterrows():
                row_data = {}
                for req_col, found_col in found_columns.items():
                    value = row[found_col]
                    # X·ª≠ l√Ω gi√° tr·ªã null/NaN
                    if pd.isna(value) or value == '' or str(value).lower() == 'nan':
                        value = None
                    else:
                        value = str(value).strip()
                    
                    # L·∫•y tr·ª±c ti·∫øp text value cho t·∫•t c·∫£ c√°c c·ªôt, bao g·ªìm "Link driver d·ªØ li·ªáu"
                    if req_col == 'Link driver d·ªØ li·ªáu':
                        print(f"   üîç Processing Link driver d·ªØ li·ªáu: '{value}'")
                        # S·ª≠ d·ª•ng tr·ª±c ti·∫øp text value m√† kh√¥ng extract hyperlink
                        if value and value != 'None':
                            print(f"   ÔøΩ Using text value for row {index}: {value}")
                        else:
                            print(f"   ‚ö†Ô∏è No text value found for row {index}")
                    
                    row_data[req_col] = value
                
                # Ch·ªâ th√™m h√†ng c√≥ √≠t nh·∫•t 1 gi√° tr·ªã kh√¥ng null
                if any(v is not None for v in row_data.values()):
                    row_data['row_index'] = index
                    extracted_data['data'].append(row_data)
            
            print(f"\nüìä ƒê√É TR√çCH XU·∫§T:")
            print(f"   üìã S·ªë h√†ng c√≥ d·ªØ li·ªáu: {len(extracted_data['data'])}")
            print(f"   üìä S·ªë c·ªôt t√¨m ƒë∆∞·ª£c: {len(found_columns)}")
            
            # Hi·ªÉn th·ªã preview d·ªØ li·ªáu
            print(f"\nüìã PREVIEW D·ªÆ LI·ªÜU:")
            for i, row_data in enumerate(extracted_data['data'][:3]):  # Ch·ªâ hi·ªÉn th·ªã 3 h√†ng ƒë·∫ßu
                print(f"   H√†ng {i+1}:")
                for req_col in required_columns:
                    if req_col in row_data:
                        value = row_data[req_col]
                        display_value = value[:50] + "..." if value and len(value) > 50 else value
                        print(f"      {req_col}: {display_value}")
                print()
            
            if len(extracted_data['data']) > 3:
                print(f"   ... v√† {len(extracted_data['data']) - 3} h√†ng kh√°c")
            
            return extracted_data
            
        except Exception as e:
            print(f"‚ùå L·ªói tr√≠ch xu·∫•t d·ªØ li·ªáu: {e}")
            return None
    
    def extract_school_data(self, sheet_id: str = None, sheet_name: str = "ED-2025") -> Optional[List[Dict[str, str]]]:
        """
        Tr√≠ch xu·∫•t d·ªØ li·ªáu tr∆∞·ªùng h·ªçc c·∫ßn thi·∫øt
        
        Args:
            sheet_id (str): Sheet ID ho·∫∑c URL
            sheet_name (str): T√™n sheet
            
        Returns:
            Optional[List[Dict[str, str]]]: Danh s√°ch d·ªØ li·ªáu tr∆∞·ªùng h·ªçc
        """
        required_columns = ['T√™n tr∆∞·ªùng', 'Admin', 'M·∫≠t kh·∫©u', 'Link driver d·ªØ li·ªáu']
        
        extracted = self.extract_required_columns(sheet_id, sheet_name, required_columns)
        
        if extracted and extracted['data']:
            # Tr·∫£ v·ªÅ ch·ªâ d·ªØ li·ªáu, b·ªè qua metadata
            return extracted['data']
        
        return None
    
    def get_school_info_summary(self, sheet_id: str = None, sheet_name: str = "ED-2025") -> Dict[str, Any]:
        """
        L·∫•y th√¥ng tin t√≥m t·∫Øt v·ªÅ d·ªØ li·ªáu tr∆∞·ªùng h·ªçc
        
        Args:
            sheet_id (str): Sheet ID ho·∫∑c URL
            sheet_name (str): T√™n sheet
            
        Returns:
            Dict[str, Any]: Th√¥ng tin t√≥m t·∫Øt
        """
        school_data = self.extract_school_data(sheet_id, sheet_name)
        
        if not school_data:
            return {'status': 'error', 'message': 'Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu'}
        
        summary = {
            'status': 'success',
            'total_schools': len(school_data),
            'schools_with_complete_info': 0,
            'schools_missing_info': 0,
            'missing_fields_stats': {
                'T√™n tr∆∞·ªùng': 0,
                'Admin': 0,
                'M·∫≠t kh·∫©u': 0,
                'Link driver d·ªØ li·ªáu': 0
            }
        }
        
        for school in school_data:
            missing_count = 0
            for field in ['T√™n tr∆∞·ªùng', 'Admin', 'M·∫≠t kh·∫©u', 'Link driver d·ªØ li·ªáu']:
                if not school.get(field):
                    summary['missing_fields_stats'][field] += 1
                    missing_count += 1
            
            if missing_count == 0:
                summary['schools_with_complete_info'] += 1
            else:
                summary['schools_missing_info'] += 1
        
        return summary
    
    def _extract_hyperlinks_from_column(self, sheet_id: str, sheet_name: str, column_name: str) -> dict:
        """
        [DEPRECATED] Tr√≠ch xu·∫•t t·∫•t c·∫£ hyperlinks t·ª´ m·ªôt c·ªôt trong Google Sheets
        NOTE: Method n√†y ƒë√£ ƒë∆∞·ª£c disable theo y√™u c·∫ßu kh√¥ng tr√≠ch xu·∫•t hyperlinks
        
        Args:
            sheet_id (str): ID c·ªßa Google Sheet
            sheet_name (str): T√™n sheet
            column_name (str): T√™n c·ªôt c·∫ßn extract hyperlinks
            
        Returns:
            dict: Empty dict (kh√¥ng c√≤n extract hyperlinks)
        """
        print(f"      ‚ÑπÔ∏è Hyperlink extraction disabled for column '{column_name}'")
        print(f"      üìù Using direct text values instead of hyperlinks")
        return {}
    
    def _extract_hyperlink_url(self, row_index: int, column_name: str, sheet_id: str, sheet_name: str = None) -> str:
        """
        Tr√≠ch xu·∫•t URL th·ª±c t·∫ø t·ª´ hyperlink trong Google Sheets cell
        
        Args:
            row_index (int): Index c·ªßa h√†ng (0-based)
            column_name (str): T√™n c·ªôt 
            sheet_id (str): ID c·ªßa Google Sheet
            sheet_name (str): T√™n sheet
            
        Returns:
            str: URL th·ª±c t·∫ø ho·∫∑c None n·∫øu kh√¥ng c√≥ hyperlink
        """
        try:
            print(f"      üîç Extracting hyperlink for row {row_index}, column '{column_name}'")
            
            # L·∫•y service t·ª´ processor
            sheets_service = self.processor.google_client.sheets_service
            
            # L·∫•y metadata ƒë·ªÉ t√¨m sheet ID
            sheet_metadata = sheets_service.spreadsheets().get(
                spreadsheetId=sheet_id
            ).execute()
            
            # T√¨m sheet ID t·ª´ t√™n
            target_sheet_id = None
            available_sheets = []
            for sheet in sheet_metadata['sheets']:
                sheet_title = sheet['properties']['title']
                available_sheets.append(sheet_title)
                if sheet_name and sheet_title == sheet_name:
                    target_sheet_id = sheet['properties']['sheetId']
                    break
                elif not sheet_name and sheet['properties']['index'] == 0:
                    target_sheet_id = sheet['properties']['sheetId']
                    break
            
            print(f"      üìã Available sheets: {available_sheets}")
            print(f"      üéØ Target sheet: {sheet_name}, ID: {target_sheet_id}")
            
            if target_sheet_id is None:
                print(f"      ‚ùå Could not find sheet ID")
                return None
            
            # T√¨m column index t·ª´ t√™n c·ªôt
            # ƒê·ªçc header ƒë·ªÉ map column name ‚Üí index
            range_name = f"{sheet_name}!1:1" if sheet_name else "A1:ZZ1"
            header_result = sheets_service.spreadsheets().values().get(
                spreadsheetId=sheet_id,
                range=range_name
            ).execute()
            
            header_values = header_result.get('values', [[]])[0] if header_result.get('values') else []
            print(f"      üìã Header values: {header_values}")
            
            column_index = None
            for i, header in enumerate(header_values):
                if str(header).strip() == column_name:
                    column_index = i
                    break
            
            print(f"      üìä Column '{column_name}' found at index: {column_index}")
            
            if column_index is None:
                print(f"      ‚ùå Column not found in header")
                return None
            
            # Chuy·ªÉn ƒë·ªïi column index th√†nh A1 notation
            def col_index_to_letter(index):
                """Convert 0-based column index to letter (A, B, C, ...)"""
                result = ""
                while index >= 0:
                    result = chr(index % 26 + ord('A')) + result
                    index = index // 26 - 1
                return result
            
            column_letter = col_index_to_letter(column_index)
            cell_address = f"{column_letter}{row_index + 2}"  # +2 v√¨ row_index 0-based v√† c√≥ header
            
            print(f"      üìç Cell address: {cell_address}")
            
            # L·∫•y cell data v·ªõi hyperlink information
            range_name = f"{sheet_name}!{cell_address}" if sheet_name else cell_address
            
            print(f"      üîç Getting cell data for range: {range_name}")
            
            result = sheets_service.spreadsheets().get(
                spreadsheetId=sheet_id,
                ranges=[range_name],
                includeGridData=True
            ).execute()
            
            print(f"      üìÑ Response keys: {result.keys()}")
            
            # Extract hyperlink URL t·ª´ response
            sheets = result.get('sheets', [])
            print(f"      üìä Number of sheets in response: {len(sheets)}")
            
            if sheets:
                data = sheets[0].get('data', [])
                print(f"      üìä Number of data sections: {len(data)}")
                
                if data:
                    row_data = data[0].get('rowData', [])
                    print(f"      üìä Number of rows: {len(row_data)}")
                    
                    if row_data:
                        values = row_data[0].get('values', [])
                        print(f"      üìä Number of values: {len(values)}")
                        
                        if values:
                            cell_data = values[0]
                            print(f"      üìä Cell data keys: {cell_data.keys()}")
                            
                            hyperlink = cell_data.get('hyperlink')
                            if hyperlink:
                                print(f"      ‚úÖ Found hyperlink: {hyperlink}")
                                return hyperlink
                            else:
                                print(f"      ‚ùå No hyperlink in cell data")
                        else:
                            print(f"      ‚ùå No values in row data")
                    else:
                        print(f"      ‚ùå No row data")
                else:
                    print(f"      ‚ùå No data sections")
            else:
                print(f"      ‚ùå No sheets in response")
            
            return None
            
        except Exception as e:
            print(f"      ‚ùå Error extracting hyperlink: {e}")
            import traceback
            print(f"      üîç Traceback: {traceback.format_exc()}")
            return None


def main():
    """Test function"""
    extractor = GoogleSheetsExtractor()
    
    print("üß™ TEST GOOGLE SHEETS EXTRACTOR")
    print("=" * 60)
    
    # Test 1: Tr√≠ch xu·∫•t d·ªØ li·ªáu tr∆∞·ªùng h·ªçc
    school_data = extractor.extract_school_data()
    
    if school_data:
        print(f"\n‚úÖ ƒê√£ tr√≠ch xu·∫•t {len(school_data)} tr∆∞·ªùng h·ªçc")
    
    # Test 2: L·∫•y th√¥ng tin t√≥m t·∫Øt
    summary = extractor.get_school_info_summary()
    print(f"\nüìä TH√îNG TIN T√ìM T·∫ÆT:")
    print(f"   Status: {summary.get('status')}")
    if summary.get('status') == 'success':
        print(f"   T·ªïng s·ªë tr∆∞·ªùng: {summary.get('total_schools')}")
        print(f"   Tr∆∞·ªùng c√≥ ƒë·ªß th√¥ng tin: {summary.get('schools_with_complete_info')}")
        print(f"   Tr∆∞·ªùng thi·∫øu th√¥ng tin: {summary.get('schools_missing_info')}")


if __name__ == "__main__":
    main()
